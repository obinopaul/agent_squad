This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
add_test_orders.py
database.py
personal_shopper.py
prompts/returns_prompt.yaml
prompts/sales_prompt.yaml
prompts/triage_prompt.yaml
README.md
utils.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="add_test_orders.py">
#!/usr/bin/env python3
import os
import sys
import logging
from database import CustomerDatabase

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("test-orders")

def add_test_orders():
    """Add test orders for Shayne Parlo."""
    # Initialize the database
    db = CustomerDatabase()
    
    # Create or get Shayne Parlo
    first_name = "Shayne"
    last_name = "Parlo"
    customer_id = db.get_or_create_customer(first_name, last_name)
    logger.info(f"Customer ID for {first_name} {last_name}: {customer_id}")
    
    # Add test orders
    
    # Order 1: Electronics
    order1 = {
        "items": [
            {
                "name": "Smartphone XS Pro",
                "quantity": 1,
                "price": 999.99
            },
            {
                "name": "Wireless Earbuds",
                "quantity": 1,
                "price": 149.99
            },
            {
                "name": "Phone Case (Black)",
                "quantity": 1,
                "price": 29.99
            }
        ],
        "total": 1179.97,
        "payment_method": "Credit Card",
        "shipping_address": "123 Main St, Anytown, USA"
    }
    
    # Order 2: Clothing
    order2 = {
        "items": [
            {
                "name": "Men's Casual Shirt (Blue)",
                "quantity": 2,
                "price": 39.99
            },
            {
                "name": "Jeans (Dark Wash)",
                "quantity": 1,
                "price": 59.99
            },
            {
                "name": "Leather Belt",
                "quantity": 1,
                "price": 34.99
            }
        ],
        "total": 174.96,
        "payment_method": "PayPal",
        "shipping_address": "123 Main St, Anytown, USA"
    }
    
    # Order 3: Home Goods
    order3 = {
        "items": [
            {
                "name": "Coffee Maker",
                "quantity": 1,
                "price": 89.99
            },
            {
                "name": "Towel Set",
                "quantity": 1,
                "price": 49.99
            },
            {
                "name": "Decorative Pillows",
                "quantity": 2,
                "price": 24.99
            }
        ],
        "total": 189.96,
        "payment_method": "Credit Card",
        "shipping_address": "123 Main St, Anytown, USA"
    }
    
    # Add orders to database
    order1_id = db.add_order(customer_id, order1)
    logger.info(f"Added Order #{order1_id}: Electronics - Total: ${order1['total']}")
    
    order2_id = db.add_order(customer_id, order2)
    logger.info(f"Added Order #{order2_id}: Clothing - Total: ${order2['total']}")
    
    order3_id = db.add_order(customer_id, order3)
    logger.info(f"Added Order #{order3_id}: Home Goods - Total: ${order3['total']}")
    
    # Verify orders were added
    order_history = db.get_customer_order_history(first_name, last_name)
    logger.info(f"Order history for {first_name} {last_name}:\n{order_history}")
    
    return order1_id, order2_id, order3_id

if __name__ == "__main__":
    order_ids = add_test_orders()
    print(f"Added test orders with IDs: {order_ids}")
    print("Test orders have been added successfully for Shayne Parlo.")
</file>

<file path="database.py">
import sqlite3
import os
import json
from typing import List, Dict, Optional, Any
import logging

logger = logging.getLogger("personal-shopper-db")
logger.setLevel(logging.INFO)

class CustomerDatabase:
    def __init__(self, db_path: str = None):
        """Initialize the customer database."""
        if db_path is None:
            # Use a default path in the same directory as this file
            script_dir = os.path.dirname(os.path.abspath(__file__))
            db_path = os.path.join(script_dir, 'customer_data.db')
        
        self.db_path = db_path
        self._initialize_db()
    
    def _initialize_db(self):
        """Create the database and tables if they don't exist."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Create customers table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS customers (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            first_name TEXT NOT NULL,
            last_name TEXT NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        ''')
        
        # Create orders table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS orders (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            customer_id INTEGER NOT NULL,
            order_details TEXT NOT NULL,
            order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (customer_id) REFERENCES customers (id)
        )
        ''')
        
        conn.commit()
        conn.close()
        logger.info(f"Database initialized at {self.db_path}")
    
    def get_or_create_customer(self, first_name: str, last_name: str) -> int:
        """Get a customer by name or create if not exists. Returns customer ID."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Check if customer exists
        cursor.execute(
            "SELECT id FROM customers WHERE first_name = ? AND last_name = ?", 
            (first_name, last_name)
        )
        result = cursor.fetchone()
        
        if result:
            customer_id = result[0]
            logger.info(f"Found existing customer: {first_name} {last_name} (ID: {customer_id})")
        else:
            # Create new customer
            cursor.execute(
                "INSERT INTO customers (first_name, last_name) VALUES (?, ?)",
                (first_name, last_name)
            )
            customer_id = cursor.lastrowid
            logger.info(f"Created new customer: {first_name} {last_name} (ID: {customer_id})")
        
        conn.commit()
        conn.close()
        return customer_id
    
    def add_order(self, customer_id: int, order_details: Dict[str, Any]) -> int:
        """Add a new order for a customer. Returns order ID."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Convert order details to JSON string
        order_json = json.dumps(order_details)
        
        cursor.execute(
            "INSERT INTO orders (customer_id, order_details) VALUES (?, ?)",
            (customer_id, order_json)
        )
        
        order_id = cursor.lastrowid
        logger.info(f"Added new order (ID: {order_id}) for customer ID: {customer_id}")
        
        conn.commit()
        conn.close()
        return order_id
    
    def get_customer_orders(self, customer_id: int) -> List[Dict[str, Any]]:
        """Get all orders for a customer."""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row  # This enables column access by name
        cursor = conn.cursor()
        
        cursor.execute(
            "SELECT id, order_details, order_date FROM orders WHERE customer_id = ? ORDER BY order_date DESC",
            (customer_id,)
        )
        
        orders = []
        for row in cursor.fetchall():
            order_data = json.loads(row['order_details'])
            orders.append({
                'id': row['id'],
                'date': row['order_date'],
                'details': order_data
            })
        
        conn.close()
        return orders
    
    def get_customer_order_history(self, first_name: str, last_name: str) -> str:
        """Get a formatted string of customer order history for LLM consumption."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Get customer ID
        cursor.execute(
            "SELECT id FROM customers WHERE first_name = ? AND last_name = ?", 
            (first_name, last_name)
        )
        result = cursor.fetchone()
        
        if not result:
            conn.close()
            return "No order history found for this customer."
        
        customer_id = result[0]
        orders = self.get_customer_orders(customer_id)
        
        if not orders:
            return f"Customer {first_name} {last_name} has no previous orders."
        
        # Format order history for LLM
        history = f"Order history for {first_name} {last_name}:\n\n"
        
        for order in orders:
            history += f"Order #{order['id']} (Date: {order['date']}):\n"
            details = order['details']
            
            if 'items' in details:
                for item in details['items']:
                    history += f"- {item.get('quantity', 1)}x {item.get('name', 'Unknown Item')}"
                    if 'price' in item:
                        history += f" (${item['price']})"
                    history += "\n"
            else:
                # Handle case where order details might be in a different format
                history += f"- {json.dumps(details)}\n"
            
            history += "\n"
        
        conn.close()
        return history
</file>

<file path="personal_shopper.py">
"""
---
title: Personal Shopper Multi-Agent
category: complex-agents
tags: [customer_database, multi_agent_transfer, order_management, customer_identification]
difficulty: advanced
description: E-commerce personal shopper with triage, sales, and returns departments
demonstrates:
  - Customer identification and database management
  - Three specialized agents with different responsibilities
  - Order creation and management with pricing
  - Order history retrieval for returns
  - Context-aware agent transfers with personalization
  - Customer database with order tracking
  - Persistent customer data across sessions
---
"""

import logging
import os
from dataclasses import dataclass, field
from typing import Optional

from dotenv import load_dotenv
from livekit.agents import JobContext, WorkerOptions, cli
from livekit.agents.llm import function_tool
from livekit.agents.voice import Agent, AgentSession, RunContext
from livekit.plugins import cartesia, deepgram, openai, silero
from livekit.plugins import noise_cancellation

from utils import load_prompt
from database import CustomerDatabase

logger = logging.getLogger("personal-shopper")
logger.setLevel(logging.INFO)

load_dotenv()

# Initialize the customer database
db = CustomerDatabase()

@dataclass
class UserData:
    """Class to store user data and agents during a call."""
    personas: dict[str, Agent] = field(default_factory=dict)
    prev_agent: Optional[Agent] = None
    ctx: Optional[JobContext] = None

    # Customer information
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    customer_id: Optional[str] = None
    current_order: Optional[dict] = None

    def is_identified(self) -> bool:
        """Check if the customer is identified."""
        return self.first_name is not None and self.last_name is not None

    def reset(self) -> None:
        """Reset customer information."""
        self.first_name = None
        self.last_name = None
        self.customer_id = None
        self.current_order = None

    def summarize(self) -> str:
        """Return a summary of the user data."""
        if self.is_identified():
            return f"Customer: {self.first_name} {self.last_name} (ID: {self.customer_id})"
        return "Customer not yet identified."

RunContext_T = RunContext[UserData]

class BaseAgent(Agent):
    async def on_enter(self) -> None:
        agent_name = self.__class__.__name__
        logger.info(f"Entering {agent_name}")

        userdata: UserData = self.session.userdata
        if userdata.ctx and userdata.ctx.room:
            await userdata.ctx.room.local_participant.set_attributes({"agent": agent_name})

        # Create a personalized prompt based on customer identification
        custom_instructions = self.instructions
        if userdata.is_identified():
            custom_instructions += f"\n\nYou are speaking with {userdata.first_name} {userdata.last_name}."

        chat_ctx = self.chat_ctx.copy()

        # Copy context from previous agent if it exists
        if userdata.prev_agent:
            items_copy = self._truncate_chat_ctx(
                userdata.prev_agent.chat_ctx.items, keep_function_call=True
            )
            existing_ids = {item.id for item in chat_ctx.items}
            items_copy = [item for item in items_copy if item.id not in existing_ids]
            chat_ctx.items.extend(items_copy)

        chat_ctx.add_message(
            role="system",
            content=f"You are the {agent_name}. {userdata.summarize()}"
        )
        await self.update_chat_ctx(chat_ctx)
        self.session.generate_reply()

    def _truncate_chat_ctx(
        self,
        items: list,
        keep_last_n_messages: int = 6,
        keep_system_message: bool = False,
        keep_function_call: bool = False,
    ) -> list:
        """Truncate the chat context to keep the last n messages."""
        def _valid_item(item) -> bool:
            if not keep_system_message and item.type == "message" and item.role == "system":
                return False
            if not keep_function_call and item.type in ["function_call", "function_call_output"]:
                return False
            return True

        new_items = []
        for item in reversed(items):
            if _valid_item(item):
                new_items.append(item)
            if len(new_items) >= keep_last_n_messages:
                break
        new_items = new_items[::-1]

        while new_items and new_items[0].type in ["function_call", "function_call_output"]:
            new_items.pop(0)

        return new_items

    async def _transfer_to_agent(self, name: str, context: RunContext_T) -> Agent:
        """Transfer to another agent while preserving context."""
        userdata = context.userdata
        current_agent = context.session.current_agent
        next_agent = userdata.personas[name]
        userdata.prev_agent = current_agent

        return next_agent


class TriageAgent(BaseAgent):
    def __init__(self) -> None:
        super().__init__(
            instructions=load_prompt('triage_prompt.yaml'),
            stt=deepgram.STT(),
            llm=openai.LLM(model="gpt-4o-mini"),
            tts=cartesia.TTS(),
            vad=silero.VAD.load()
        )

    @function_tool
    async def identify_customer(self, first_name: str, last_name: str):
        """
        Identify a customer by their first and last name.

        Args:
            first_name: The customer's first name
            last_name: The customer's last name
        """
        userdata: UserData = self.session.userdata
        userdata.first_name = first_name
        userdata.last_name = last_name
        userdata.customer_id = db.get_or_create_customer(first_name, last_name)

        return f"Thank you, {first_name}. I've found your account."

    @function_tool
    async def transfer_to_sales(self, context: RunContext_T) -> Agent:
        # Create a personalized message if customer is identified
        userdata: UserData = self.session.userdata
        if userdata.is_identified():
            message = f"Thank you, {userdata.first_name}. I'll transfer you to our Sales team who can help you find the perfect product."
        else:
            message = "I'll transfer you to our Sales team who can help you find the perfect product."

        await self.session.say(message)
        return await self._transfer_to_agent("sales", context)

    @function_tool
    async def transfer_to_returns(self, context: RunContext_T) -> Agent:
        # Create a personalized message if customer is identified
        userdata: UserData = self.session.userdata
        if userdata.is_identified():
            message = f"Thank you, {userdata.first_name}. I'll transfer you to our Returns department who can assist with your return or exchange."
        else:
            message = "I'll transfer you to our Returns department who can assist with your return or exchange."

        await self.session.say(message)
        return await self._transfer_to_agent("returns", context)


class SalesAgent(BaseAgent):
    def __init__(self) -> None:
        super().__init__(
            instructions=load_prompt('sales_prompt.yaml'),
            stt=deepgram.STT(),
            llm=openai.LLM(model="gpt-4o-mini"),
            tts=cartesia.TTS(),
            vad=silero.VAD.load()
        )

    @function_tool
    async def identify_customer(self, first_name: str, last_name: str):
        """
        Identify a customer by their first and last name.

        Args:
            first_name: The customer's first name
            last_name: The customer's last name
        """
        userdata: UserData = self.session.userdata
        userdata.first_name = first_name
        userdata.last_name = last_name
        userdata.customer_id = db.get_or_create_customer(first_name, last_name)

        return f"Thank you, {first_name}. I've found your account."

    @function_tool
    async def start_order(self):
        """Start a new order for the customer."""
        userdata: UserData = self.session.userdata
        if not userdata.is_identified():
            return "Please identify the customer first using the identify_customer function."

        userdata.current_order = {
            "items": []
        }

        return "I've started a new order for you. What would you like to purchase?"

    @function_tool
    async def add_item_to_order(self, item_name: str, quantity: int, price: float):
        """
        Add an item to the current order.

        Args:
            item_name: The name of the item
            quantity: The quantity to purchase
            price: The price per item
        """
        userdata: UserData = self.session.userdata
        if not userdata.is_identified():
            return "Please identify the customer first using the identify_customer function."

        if not userdata.current_order:
            userdata.current_order = {"items": []}

        item = {
            "name": item_name,
            "quantity": quantity,
            "price": price
        }

        userdata.current_order["items"].append(item)

        return f"Added {quantity}x {item_name} to your order."

    @function_tool
    async def complete_order(self):
        """Complete the current order and save it to the database."""
        userdata: UserData = self.session.userdata
        if not userdata.is_identified():
            return "Please identify the customer first using the identify_customer function."

        if not userdata.current_order or not userdata.current_order.get("items"):
            return "There are no items in the current order."

        # Calculate order total
        total = sum(item["price"] * item["quantity"] for item in userdata.current_order["items"])
        userdata.current_order["total"] = total

        # Save order to database
        order_id = db.add_order(userdata.customer_id, userdata.current_order)

        # Create a summary of the order
        summary = f"Order #{order_id} has been completed. Total: ${total:.2f}\n"
        summary += "Items:\n"
        for item in userdata.current_order["items"]:
            summary += f"- {item['quantity']}x {item['name']} (${item['price']} each)\n"

        # Reset the current order
        userdata.current_order = None

        return summary

    @function_tool
    async def transfer_to_triage(self, context: RunContext_T) -> Agent:
        # Create a personalized message if customer is identified
        userdata: UserData = self.session.userdata
        if userdata.is_identified():
            message = f"Thank you, {userdata.first_name}. I'll transfer you back to our Triage agent who can better direct your inquiry."
        else:
            message = "I'll transfer you back to our Triage agent who can better direct your inquiry."

        await self.session.say(message)
        return await self._transfer_to_agent("triage", context)

    @function_tool
    async def transfer_to_returns(self, context: RunContext_T) -> Agent:
        # Create a personalized message if customer is identified
        userdata: UserData = self.session.userdata
        if userdata.is_identified():
            message = f"Thank you, {userdata.first_name}. I'll transfer you to our Returns department for assistance with your return request."
        else:
            message = "I'll transfer you to our Returns department for assistance with your return request."

        await self.session.say(message)
        return await self._transfer_to_agent("returns", context)


class ReturnsAgent(BaseAgent):
    def __init__(self) -> None:
        super().__init__(
            instructions=load_prompt('returns_prompt.yaml'),
            stt=deepgram.STT(),
            llm=openai.LLM(model="gpt-4o-mini"),
            tts=cartesia.TTS(),
            vad=silero.VAD.load()
        )

    @function_tool
    async def identify_customer(self, first_name: str, last_name: str):
        """
        Identify a customer by their first and last name.

        Args:
            first_name: The customer's first name
            last_name: The customer's last name
        """
        userdata: UserData = self.session.userdata
        userdata.first_name = first_name
        userdata.last_name = last_name
        userdata.customer_id = db.get_or_create_customer(first_name, last_name)

        return f"Thank you, {first_name}. I've found your account."

    @function_tool
    async def get_order_history(self):
        """Get the order history for the current customer."""
        userdata: UserData = self.session.userdata
        if not userdata.is_identified():
            return "Please identify the customer first using the identify_customer function."

        order_history = db.get_customer_order_history(userdata.first_name, userdata.last_name)
        return order_history

    @function_tool
    async def process_return(self, order_id: int, item_name: str, reason: str):
        """
        Process a return for an item from a specific order.

        Args:
            order_id: The ID of the order containing the item to return
            item_name: The name of the item to return
            reason: The reason for the return
        """
        userdata: UserData = self.session.userdata
        if not userdata.is_identified():
            return "Please identify the customer first using the identify_customer function."

        # In a real system, we would update the order in the database
        # For this example, we'll just return a confirmation message
        return f"Return processed for {item_name} from Order #{order_id}. Reason: {reason}. A refund will be issued within 3-5 business days."

    @function_tool
    async def transfer_to_triage(self, context: RunContext_T) -> Agent:
        # Create a personalized message if customer is identified
        userdata: UserData = self.session.userdata
        if userdata.is_identified():
            message = f"Thank you, {userdata.first_name}. I'll transfer you back to our Triage agent who can better direct your inquiry."
        else:
            message = "I'll transfer you back to our Triage agent who can better direct your inquiry."

        await self.session.say(message)
        return await self._transfer_to_agent("triage", context)

    @function_tool
    async def transfer_to_sales(self, context: RunContext_T) -> Agent:
        # Create a personalized message if customer is identified
        userdata: UserData = self.session.userdata
        if userdata.is_identified():
            message = f"Thank you, {userdata.first_name}. I'll transfer you to our Sales team who can help you find new products."
        else:
            message = "I'll transfer you to our Sales team who can help you find new products."

        await self.session.say(message)
        return await self._transfer_to_agent("sales", context)


async def entrypoint(ctx: JobContext):
    # Initialize user data with context
    userdata = UserData(ctx=ctx)

    # Create agent instances
    triage_agent = TriageAgent()
    sales_agent = SalesAgent()
    returns_agent = ReturnsAgent()

    # Register all agents in the userdata
    userdata.personas.update({
        "triage": triage_agent,
        "sales": sales_agent,
        "returns": returns_agent
    })

    # Create session with userdata
    session = AgentSession[UserData](userdata=userdata)

    await session.start(
        agent=triage_agent,  # Start with the Triage agent
        room=ctx.room
    )

if __name__ == "__main__":
    cli.run_app(WorkerOptions(entrypoint_fnc=entrypoint))
</file>

<file path="prompts/returns_prompt.yaml">
instructions: |
  You are the Returns agent for our personal shopping service. You help customers with returning 
  items, processing refunds, and resolving issues with their purchases. Be patient and solution-oriented.
  
  Return Policies:
  - 60-day return window for most items
  - Items must be in original condition with tags attached
  - Original receipt or order number required for all returns
  - Free return shipping for defective items
  - Store credit offered for returns without receipt
  - Expedited refunds available for loyalty program members
  - Special items (electronics, perishables) have a 14-day return window
  
  Follow these guidelines:
  - Greet the customer and express that you're here to help with their return
  - If the customer hasn't been identified yet, ask for their first and last name and use the identify_customer function
  - Use get_order_history to retrieve the customer's previous orders
  - Ask for the order number and item they wish to return
  - Determine the reason for the return to provide the appropriate solution
  - Use process_return to handle the return (requires order ID, item name, and reason)
  - Clearly explain the return process and any applicable policies
  - Process the return or exchange efficiently
  - Offer alternatives if the return doesn't meet policy requirements
  - Thank them for their patience and ask if they need help with anything else
  
  Return Process:
  1. Identify the customer using identify_customer
  2. Retrieve their order history using get_order_history
  3. Confirm which item they want to return and from which order
  4. Process the return using process_return
  
  Always verify that the item being returned exists in the customer's order history before processing the return.
</file>

<file path="prompts/sales_prompt.yaml">
instructions: |
  You are the Sales agent for our personal shopping service. You help customers find and purchase 
  products that meet their needs. Be enthusiastic and knowledgeable about our product offerings.
  
  Sales Policies:
  - We offer a 30-day price match guarantee on all items
  - Free shipping on orders over $50
  - 10% discount for first-time customers (promo code: WELCOME10)
  - Loyalty program members earn 2 points per dollar spent
  - Financing available on purchases over $200
  
  Follow these guidelines:
  - Greet the customer warmly and ask about their shopping needs
  - If the customer hasn't been identified yet, ask for their first and last name and use the identify_customer function
  - Ask questions to understand their preferences, budget, and requirements
  - Make personalized product recommendations based on their needs
  - Highlight key features and benefits of recommended products
  - Inform customers about current promotions and discounts
  - Use start_order to begin a new order for the customer
  - Use add_item_to_order to add each item the customer wants to purchase
  - When the order is complete, use complete_order to finalize the purchase
  - Thank them for their business and offer additional assistance if needed
  
  Order Process:
  1. Identify the customer using identify_customer
  2. Start a new order using start_order
  3. Add items to the order using add_item_to_order (include item name, quantity, and price)
  4. Complete the order using complete_order
  
  Remember that all customer orders are saved to our database and will be available if they need to make a return later.
</file>

<file path="prompts/triage_prompt.yaml">
instructions: |
  You are the Personal Shopper Triage agent. Your job is to determine if the customer needs 
  help with making a purchase (Sales) or returning an item (Returns). Ask questions to understand 
  their needs, then transfer them to the appropriate department.
  
  Follow these guidelines:
  - Greet the customer warmly and ask how you can help them with their shopping needs today
  - Ask for the customer's first and last name to identify them in our system using the identify_customer function
  - Listen carefully to determine if they want to make a purchase or return an item
  - Ask clarifying questions if needed to properly categorize their request
  - Transfer them to the appropriate department once you understand their needs
  - If the customer has multiple issues, address the primary concern first
  - Be friendly, helpful, and make the customer feel valued
  
  Important: Always identify the customer before transferring them to another department. This ensures their information and order history will be available to the next agent.
</file>

<file path="README.md">
# Personal Shopper Agent

A multi-agent voice-enabled personal shopping assistant example that handles customer inquiries, sales, and returns using LiveKit's voice agents.

## Overview

This system employs three specialized agents that work together to provide comprehensive customer service:

1. **TriageAgent** - The initial point of contact that identifies customers and routes them to the appropriate department
2. **SalesAgent** - Assists customers with product selection and order placement
3. **ReturnsAgent** - Handles return requests and provides order history information

## Features

- **Multi-Agent Architecture**: Seamless transfer between specialized agents with context preservation
- **Customer Identification**: Persistent customer database tracks shoppers and their order history
- **Context Preservation**: Conversation history transfers between agents for continuity
- **Order Management**: Complete order workflow from item selection to checkout
- **Return Processing**: Access order history and process returns with reasons
- **Voice-Enabled**: Built using LiveKit's voice capabilities with support for:
  - Speech-to-Text (STT) using Deepgram
  - Large Language Model (LLM) using OpenAI GPT-4o-mini
  - Text-to-Speech (TTS) using Cartesia
  - Voice Activity Detection (VAD) using Silero
- **SQLite Database**: Persistent storage for customers and orders

## How It Works

1. Customer connects and is greeted by the Triage agent
2. Triage agent asks for the customer's name and identifies them in the system
3. Based on the customer's needs, they are transferred to either:
   - Sales agent for making purchases
   - Returns agent for processing returns
4. Agents can transfer customers between departments as needed
5. All customer information and order history persists across sessions
6. Context and conversation history follows the customer between agents

## Prerequisites

- Python 3.10+
- `livekit-agents`>=1.0
- LiveKit account and credentials
- API keys for:
  - OpenAI (for LLM capabilities)
  - Deepgram (for speech-to-text)
  - Cartesia (for text-to-speech)

## Installation

1. Clone the repository

2. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

3. Create a `.env` file with your API credentials:
   ```
   LIVEKIT_URL=your_livekit_url
   LIVEKIT_API_KEY=your_api_key
   LIVEKIT_API_SECRET=your_api_secret
   OPENAI_API_KEY=your_openai_key
   DEEPGRAM_API_KEY=your_deepgram_key
   CARTESIA_API_KEY=your_cartesia_key
   ```

## Running the Agent

```bash
python personal_shopper.py console
```

The agent will connect and start with the Triage agent ready to assist customers.

## Architecture Details

### Main Classes

- **UserData**: Stores session data including customer information, current order, and agent references
- **BaseAgent**: Parent class providing common functionality like context preservation and agent transfer
- **TriageAgent**: Routes customers to appropriate departments
- **SalesAgent**: Handles product selection and order placement
- **ReturnsAgent**: Processes returns and provides order history

### Agent Transfer Flow

1. Current agent's context is preserved in UserData
2. Transfer function creates personalized transition message
3. Next agent receives truncated conversation history
4. Customer identification persists across transfers

### Database Schema

The SQLite database (`customer_data.db`) contains:
- **customers**: Stores customer names and IDs
- **orders**: Stores order details as JSON with customer references

### Prompt Management

Agent personalities and instructions are loaded from YAML files in the `prompts/` directory:
- `triage_prompt.yaml`: Instructions for initial customer routing
- `sales_prompt.yaml`: Guidelines for sales interactions
- `returns_prompt.yaml`: Return processing instructions

## Customization

1. **Modify Agent Behavior**: Edit the YAML prompt files to change agent personalities and instructions
2. **Add New Agents**: Create new agent classes inheriting from BaseAgent and register them in the entrypoint
3. **Extend Order Management**: Add more fields to the order structure or implement inventory tracking
4. **Change Voice Providers**: Replace Deepgram, OpenAI, or Cartesia with other supported providers
</file>

<file path="utils.py">
import os
import yaml

def load_prompt(filename):
    """Load a prompt from a YAML file."""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    prompt_path = os.path.join(script_dir, 'prompts', filename)
    
    try:
        with open(prompt_path, 'r') as file:
            prompt_data = yaml.safe_load(file)
            return prompt_data.get('instructions', '')
    except (FileNotFoundError, yaml.YAMLError) as e:
        print(f"Error loading prompt file {filename}: {e}")
        return ""
</file>

</files>
